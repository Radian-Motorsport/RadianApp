<!DOCTYPE html>
<html lang="en">
<!--
  ====================================================================
  TODO FOR APP DEVELOPMENT TEAM - RACING APP USER AGENT IDENTIFICATION
  ====================================================================
  
  When rebuilding the racing app, please implement the following:
  
  1. SET CUSTOM USER AGENT:
     - App should send custom User-Agent header: "RadianTelemetryApp/1.0" or similar
     - This distinguishes the app from web browser viewers
     - Example implementations:
       * Socket.io client option: { extraHeaders: { 'User-Agent': 'RadianTelemetryApp/1.0' } }
       * HTTP client header: User-Agent: "RadianTelemetryApp/1.0 (Windows)"
  
  2. APP BEHAVIOR:
     - Apps will appear in "üéÆ Racing Apps" section regardless of broadcastingEnabled status
     - broadcastingEnabled = true  ‚Üí "üì° BROADCASTING" 
     - broadcastingEnabled = false ‚Üí "‚è∏Ô∏è STANDBY"
     - Web viewers will always appear in "üë• Viewers & Spectators" section
  
  3. CURRENT DETECTION PATTERNS:
     - Server checks for: "RadianTelemetryApp", "RadianApp", or "Radian" in User-Agent
     - Fallback patterns can be adjusted as needed
  
  4. BENEFITS:
     - Clear distinction between drivers and spectators
     - Apps in standby mode don't appear as viewers
     - Better admin overview of system usage
  
  ====================================================================
-->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connection Status - Radian</title>
  <!-- External Dependencies -->
  <script src="/socket.io/socket.io.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <style>
    .connection-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    
    .connection-block {
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }
    
    .connection-list {
      max-height: 300px;
      overflow-y: auto;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 10px;
    }
    
    .client-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .client-item:last-child {
      border-bottom: none;
    }
    
    .system-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    /* Mobile responsive styles for connections page */
    @media (max-width: 768px) {
      .connection-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .system-info {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      .connection-block {
        padding: 12px;
      }
      
      .big-number {
        font-size: 2em !important;
      }
      
      .connection-stats {
        font-size: 1.1em !important;
      }
    }

    @media (max-width: 480px) {
      .connection-grid {
        gap: 10px;
      }
      
      .connection-block {
        padding: 10px;
      }
      
      .big-number {
        font-size: 1.8em !important;
      }
      
      .connection-stats {
        font-size: 1em !important;
      }
      
      .broadcast-info {
        flex-direction: column;
        gap: 10px;
        padding: 12px;
      }
      
      .admin-actions {
        flex-direction: column;
        gap: 8px;
      }
      
      .client-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
        padding: 6px;
      }
      
      .info-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
        font-size: 0.9rem;
      }
      
      .info-value {
        font-size: 0.85rem;
      }
      
      .connection-list {
        max-height: 250px;
        padding: 8px;
      }
    }
    
    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    
    .info-value {
      font-weight: bold;
    }
    
    .status-good {
      color: #4caf50;
    }
    
    .status-warning {
      color: #ff9800;
    }
    
    .status-error {
      color: #f44336;
    }
    
    .connection-stats {
      text-align: center;
      font-size: 1.2em;
      margin: 20px 0;
    }
    
    .big-number {
      font-size: 2.5em;
      font-weight: bold;
      margin: 5px 0;
    }
    
    .broadcast-info {
      display: flex;
      justify-content: space-between;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .admin-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .admin-button {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      background-color: #1e88e5;
      color: white;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
    }
    
    .admin-button.danger {
      background-color: #e53935;
    }
    
    .admin-button:hover {
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <!-- Top Bar -->
  <div id="topBar" class="top-bar"></div>
  
  <!-- Main Dashboard Header -->
  <div class="telemetry-block">
    <h2>Connection Status Dashboard</h2>
    
    <!-- Summary Stats -->
    <div class="connection-stats">
      <div>Connected Clients</div>
      <div class="big-number" id="connectionCount">0</div>
      <div style="font-size: 0.9em; margin-top: -10px; color: #4caf50;">
        <span id="broadcastingCount">0</span> actively broadcasting
      </div>
      <div>Server Uptime: <span id="serverUptime">--:--:--</span></div>
    </div>
    
    <!-- Broadcaster Info -->
    <div class="broadcast-info">
      <div>
        <label>Current Driver:</label>
        <span id="currentDriver">--</span>
      </div>
      <div>
        <label>Session ID:</label>
        <span id="sessionId">--</span>
      </div>
    </div>
  </div>

  <!-- Detailed Connection Info -->
  <div class="telemetry-block">
    <h2>System Status <span class="info-badge" title="Detailed system information">‚ÑπÔ∏è</span></h2>
    <div class="connection-grid">
      <!-- App Connections (Racing Apps) -->
      <div class="connection-block">
        <h3>üéÆ Racing Apps <span id="appCount" style="color: #4caf50;">(0)</span></h3>
        <div class="connection-list" id="appList">
          <div class="client-item">
            <span>No racing apps connected</span>
          </div>
        </div>
        <!-- TODO FOR APP DEVELOPMENT: Apps should send custom User-Agent header -->
        <!-- TODO FOR APP DEVELOPMENT: Example: "RadianTelemetryApp/1.0 (Windows)" -->
        <!-- TODO FOR APP DEVELOPMENT: This will show apps here regardless of broadcastingEnabled status -->
      </div>
      
      <!-- Viewer Connections (Web browsers, mobile, tablets) -->
      <div class="connection-block">
        <h3>üë• Viewers & Spectators <span id="viewerCount" style="color: #ff9800;">(0)</span></h3>
        <div class="connection-list" id="viewerList">
          <div class="client-item">
            <span>No viewers connected</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- System Info (moved to full width below) -->
    <div class="connection-block" style="margin-top: 20px;">
      <h3>Server Information</h3>
      <div class="system-info">
        <div class="info-item">
          <span>Socket.io Status:</span>
          <span class="info-value status-good" id="socketStatus">Connected</span>
        </div>
        <div class="info-item">
          <span>Last Data Received:</span>
          <span class="info-value" id="lastDataTime">--:--:--</span>
        </div>
        <div class="info-item">
          <span>Telemetry Rate:</span>
          <span class="info-value" id="telemetryRate">-- Hz</span>
        </div>
        <div class="info-item">
          <span>API Status:</span>
          <span class="info-value status-good" id="apiStatus">Operational</span>
        </div>
      </div>
    </div>
    
    <!-- Admin Actions -->
    <div class="admin-actions">
      <button class="admin-button danger" id="resetButton">Reset All Data</button>
    </div>
  </div>

  <!-- Connection History -->
  <div class="telemetry-block">
    <h2>Connection History <span class="info-badge" title="Recent connection events">‚ÑπÔ∏è</span></h2>
    <div class="connection-list" id="connectionHistory">
      <div class="client-item">
        <span>No connection history available</span>
      </div>
    </div>
  </div>

  <!-- JavaScript Resources -->
  <script src="storage-manager.js"></script>
  <script>
    // Socket.io connection (independent from telemetry.js)
    const socket = io('https://radianapp.onrender.com');
    
    // Connection tracking (using some variables from telemetry.js)
    let connectionStartTime = Date.now();
    let connectedClients = [];
    let connectionHistory = [];
    let lastConnectionInfo = null; // Store last connection info
    let previousConnectionInfo = null; // Store previous state for comparison
    
    // Telemetry rate tracking
    let telemetryPacketCount = 0;
    let telemetryStartTime = Date.now();
    let connectionsPageLastTelemetryTime = null; // Local variable for connections page
    
    // DOM elements (will be cached after DOM loads)
    let connectionCountEl, broadcastingCountEl, serverUptimeEl, currentDriverEl, sessionIdEl;
    let appListEl, viewerListEl, appCountEl, viewerCountEl; // New separate lists for apps vs viewers
    let socketStatusEl, lastDataTimeEl, telemetryRateEl;
    let apiStatusEl, connectionHistoryEl, resetButton;
    
    // Initialize page
    document.addEventListener('DOMContentLoaded', () => {
      // Cache DOM elements after DOM is loaded
      connectionCountEl = document.getElementById('connectionCount');
      broadcastingCountEl = document.getElementById('broadcastingCount');
      serverUptimeEl = document.getElementById('serverUptime');
      currentDriverEl = document.getElementById('currentDriver');
      sessionIdEl = document.getElementById('sessionId');
      // New separate list elements
      appListEl = document.getElementById('appList');
      viewerListEl = document.getElementById('viewerList');
      appCountEl = document.getElementById('appCount');
      viewerCountEl = document.getElementById('viewerCount');
      socketStatusEl = document.getElementById('socketStatus');
      lastDataTimeEl = document.getElementById('lastDataTime');
      telemetryRateEl = document.getElementById('telemetryRate');
      apiStatusEl = document.getElementById('apiStatus');
      connectionHistoryEl = document.getElementById('connectionHistory');
      
      // Cache buttons
      resetButton = document.getElementById('resetButton');
      updateConnectionTime();
      setInterval(updateConnectionTime, 1000);
      
      // Initialize telemetry display
      telemetryRateEl.textContent = '-- Hz';
      lastDataTimeEl.textContent = '--:--:--';
      
      // Periodically request connection info to stay updated (less frequently)
      setInterval(() => {
        if (socket.connected) {
          socket.emit('requestConnectionInfo');
        }
      }, 15000); // Every 15 seconds instead of 5
      
      // Set up button handlers
      resetButton.addEventListener('click', () => {
        if (confirm('Are you sure you want to reset all telemetry data for all connected clients?')) {
          socket.emit('resetTelemetryState');
          addConnectionEvent('Telemetry data reset initiated');
        }
      });
    });
    
    // Socket event handlers
    socket.on('connect', () => {
      console.log('Connected to server, requesting connection info...');
      socketStatusEl.textContent = 'Connected';
      socketStatusEl.className = 'info-value status-good';
      addConnectionEvent('Connected to server');
      
      // Request connection info after we're connected
      setTimeout(() => {
        socket.emit('requestConnectionInfo');
      }, 100); // Small delay to ensure server has processed our connection
    });
    
    socket.on('disconnect', () => {
      socketStatusEl.textContent = 'Disconnected';
      socketStatusEl.className = 'info-value status-error';
      addConnectionEvent('Disconnected from server');
    });
    
    socket.on('telemetry', (data) => {
      const now = new Date();
      connectionsPageLastTelemetryTime = now; // Use local variable
      lastDataTimeEl.textContent = `${now.toLocaleTimeString()}`;
      
      // Track telemetry rate
      telemetryPacketCount++;
      const elapsedSeconds = (Date.now() - telemetryStartTime) / 1000;
      
      if (elapsedSeconds >= 1) { // Update rate every second
        const rate = (telemetryPacketCount / elapsedSeconds).toFixed(1);
        telemetryRateEl.textContent = `${rate} Hz`;
        
        // Reset counters for next calculation
        telemetryPacketCount = 0;
        telemetryStartTime = Date.now();
      }
    });
    
    socket.on('connectionInfo', (info) => {
      console.log('Received connection info:', info);
      
      // Check what changed and only log meaningful events
      let changesDetected = [];
      
      if (previousConnectionInfo) {
        // Check client count change
        if (info.clientCount !== previousConnectionInfo.clientCount) {
          changesDetected.push(`Client count: ${previousConnectionInfo.clientCount} ‚Üí ${info.clientCount}`);
        }
        
        // Check API status change
        if (info.apiStatus !== previousConnectionInfo.apiStatus) {
          changesDetected.push(`API status: ${previousConnectionInfo.apiStatus} ‚Üí ${info.apiStatus}`);
        }
        
        // Check storage status change
        if (info.storageActive !== previousConnectionInfo.storageActive) {
          changesDetected.push(`Storage: ${previousConnectionInfo.storageActive ? 'Active' : 'Inactive'} ‚Üí ${info.storageActive ? 'Active' : 'Inactive'}`);
        }
      } else {
        // First time receiving connection info
        changesDetected.push('Initial connection info received');
      }
      
      // Store previous state for next comparison
      previousConnectionInfo = {
        clientCount: info.clientCount,
        apiStatus: info.apiStatus,
        storageActive: info.storageActive
      };
      
      // Store last connection info
      lastConnectionInfo = info;
      
      // Update connection count
      connectionCountEl.textContent = info.clientCount || '0';
      
      // Calculate and update broadcasting count
      const clients = info.clients || [];
      const racingApps = info.racingApps || [];
      const webViewers = info.webViewers || [];
      const broadcastingCount = racingApps.filter(client => client.broadcastingEnabled).length;
      broadcastingCountEl.textContent = broadcastingCount;
      
      // Update client list with separate sections
      updateClientList(racingApps, webViewers);
      
      // Update server info
      serverUptimeEl.textContent = formatTime(info.uptime || 0);
      apiStatusEl.textContent = info.apiStatus || 'Unknown';
      apiStatusEl.className = info.apiStatus === 'Operational' 
        ? 'info-value status-good' 
        : 'info-value status-warning';
      
      // Only log if there were meaningful changes
      if (changesDetected.length > 0) {
        changesDetected.forEach(change => addConnectionEvent(change));
      }
    });
    
    socket.on('currentBroadcaster', (info) => {
      console.log('Received currentBroadcaster:', info);
      
      // Only update if the driver or sessionId actually changed
      const currentDriver = currentDriverEl.textContent;
      const currentSession = sessionIdEl.textContent;
      
      if (info.driver !== currentDriver || info.sessionId !== currentSession) {
        currentDriverEl.textContent = info.driver || '--';
        sessionIdEl.textContent = info.sessionId || '--';
        addConnectionEvent(`Broadcaster updated: ${info.driver} (Session: ${info.sessionId})`);
      }
    });
    
    socket.on('clientConnect', (clientInfo) => {
      // Check if this client is broadcasting (has driver name)
      const clientData = lastConnectionInfo?.clients?.find(c => c.id === clientInfo.id);
      const displayName = clientData?.driverName ? 
        `${clientData.driverName} (${clientInfo.id.substring(0, 6)})` : 
        `Client ${clientInfo.id.substring(0, 6)}`;
      
      addConnectionEvent(`New client connected: ${displayName}`);
      socket.emit('requestConnectionInfo');
    });
    
    socket.on('clientDisconnect', (clientInfo) => {
      addConnectionEvent(`Client disconnected: ${clientInfo.id.substring(0, 6)}`);
      socket.emit('requestConnectionInfo');
    });
    
    socket.on('telemetryStateReset', () => {
      addConnectionEvent('Telemetry data has been reset by another user');
    });
    
    // Helper functions
    function updateConnectionTime() {
      const elapsedSeconds = Math.floor((Date.now() - connectionStartTime) / 1000);
      serverUptimeEl.textContent = formatTime(elapsedSeconds);
      
      // Check if telemetry data is stale
      if (connectionsPageLastTelemetryTime && typeof connectionsPageLastTelemetryTime.getTime === 'function') {
        const timeSinceLastData = Math.floor((Date.now() - connectionsPageLastTelemetryTime.getTime()) / 1000);
        if (timeSinceLastData > 5) { // No data for 5+ seconds
          telemetryRateEl.textContent = '0 Hz';
          telemetryRateEl.style.color = '#f44336'; // Red color for no data
        } else {
          telemetryRateEl.style.color = '#4caf50'; // Green color for active data
        }
      } else {
        telemetryRateEl.textContent = '-- Hz';
        telemetryRateEl.style.color = '#ff9800'; // Orange for waiting
      }
    }
    
    function updateClientList(racingApps, webViewers) {
      console.log('Updating client list with racing apps:', racingApps, 'and web viewers:', webViewers);
      if (!appListEl || !viewerListEl) return;
      
      // Update Racing Apps list
      appListEl.innerHTML = '';
      if (racingApps && racingApps.length > 0) {
        racingApps.forEach(client => {
          const clientEl = document.createElement('div');
          clientEl.className = 'client-item racing-app';
          clientEl.style.justifyContent = 'center';
          clientEl.style.border = '1px solid #4caf50';
          clientEl.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
          
          const idSpan = document.createElement('span');
          
          if (client.driverName) {
            let status = '';
            let statusColor = '';
            
            if (client.isActiveBroadcaster) {
              status = ' üì° BROADCASTING';
              statusColor = '#4caf50';
            } else if (client.broadcastingEnabled) {
              status = ' ‚è∏Ô∏è STANDBY';
              statusColor = '#ff9800';
            } else {
              status = ' üîó Connected';
              statusColor = '#2196f3';
            }
            
            idSpan.innerHTML = `${client.driverName}<br><small style="color: ${statusColor};">${status}</small>`;
            idSpan.style.fontWeight = 'bold';
            idSpan.style.color = '#ffffff';
          } else {
            idSpan.innerHTML = `Racing App<br><small style="color: #ff9800;">Connected</small>`;
          }
          
          idSpan.style.textAlign = 'center';
          clientEl.appendChild(idSpan);
          appListEl.appendChild(clientEl);
        });
      } else {
        // Show "no apps connected" message
        appListEl.innerHTML = '<div class="client-item"><span>No racing apps connected</span></div>';
      }
      
      // Update Web Viewers list
      viewerListEl.innerHTML = '';
      if (webViewers && webViewers.length > 0) {
        webViewers.forEach(client => {
          const clientEl = document.createElement('div');
          clientEl.className = 'client-item web-viewer';
          clientEl.style.justifyContent = 'center';
          clientEl.style.border = '1px solid #2196f3';
          clientEl.style.backgroundColor = 'rgba(33, 150, 243, 0.1)';
          
          const idSpan = document.createElement('span');
          idSpan.innerHTML = `Viewer<br><small style="color: #2196f3;">ID: ${client.id.substring(0, 6)}...</small>`;
          idSpan.style.textAlign = 'center';
          idSpan.style.color = '#ffffff';
          
          clientEl.appendChild(idSpan);
          viewerListEl.appendChild(clientEl);
        });
      } else {
        // Show "no viewers connected" message
        viewerListEl.innerHTML = '<div class="client-item"><span>No viewers connected</span></div>';
      }
    }
    
    function updateAppList(appClients) {
      if (!appListEl) return;
      
      appListEl.innerHTML = '';
      if (appClients.length === 0) {
        appListEl.innerHTML = '<div class="client-item"><span>No racing apps connected</span></div>';
        return;
      }
      
      appClients.forEach(client => {
        const clientEl = document.createElement('div');
        clientEl.className = 'client-item';
        clientEl.style.justifyContent = 'center';
        
        const idSpan = document.createElement('span');
        const isBroadcasting = client.broadcastingEnabled;
        
        // Apps show driver name if available, or indicate it's an app
        if (client.driverName) {
          const status = isBroadcasting ? ' üì° BROADCASTING' : ' ‚è∏Ô∏è STANDBY';
          const statusColor = isBroadcasting ? '#4caf50' : '#ff9800';
          
          idSpan.innerHTML = `üéÆ ${client.driverName}<br><small style="color: ${statusColor};">${status}</small>`;
          idSpan.style.fontWeight = 'bold';
          idSpan.style.color = isBroadcasting ? '#4caf50' : '#ffffff';
        } else {
          const status = isBroadcasting ? ' üì° BROADCASTING' : ' ‚è∏Ô∏è STANDBY';
          const statusColor = isBroadcasting ? '#4caf50' : '#ff9800';
          idSpan.innerHTML = `üéÆ Racing App<br><small style="color: ${statusColor};">ID: ${client.id.substring(0, 6)}... ${status}</small>`;
        }
        idSpan.style.textAlign = 'center';
        
        clientEl.appendChild(idSpan);
        appListEl.appendChild(clientEl);
      });
    }
    
    function updateViewerList(viewerClients) {
      if (!viewerListEl) return;
      
      viewerListEl.innerHTML = '';
      if (viewerClients.length === 0) {
        viewerListEl.innerHTML = '<div class="client-item"><span>No viewers connected</span></div>';
        return;
      }
      
      viewerClients.forEach(client => {
        const clientEl = document.createElement('div');
        clientEl.className = 'client-item';
        clientEl.style.justifyContent = 'center';
        
        const idSpan = document.createElement('span');
        
        // Detect device type from user agent for viewers
        const deviceType = getDeviceType(client.userAgent);
        
        idSpan.innerHTML = `${deviceType} Viewer<br><small style="color: #ff9800;">ID: ${client.id.substring(0, 6)}... üîó Connected</small>`;
        idSpan.style.textAlign = 'center';
        
        clientEl.appendChild(idSpan);
        viewerListEl.appendChild(clientEl);
      });
    }
    
    function getDeviceType(userAgent) {
      if (!userAgent) return 'üíª';
      
      const ua = userAgent.toLowerCase();
      if (ua.includes('iphone')) return 'üì±';
      if (ua.includes('android') && ua.includes('mobile')) return 'üì±';
      if (ua.includes('ipad')) return 'üìã';
      if (ua.includes('android')) return 'üìã';
      if (ua.includes('tablet')) return 'üìã';
      if (ua.includes('windows') || ua.includes('macintosh') || ua.includes('linux')) return 'üíª';
      
      return 'üíª'; // Default to desktop
    }
    
    function addConnectionEvent(message) {
      if (!connectionHistoryEl) return;
      
      const now = new Date();
      const timeString = now.toLocaleTimeString();
      
      connectionHistory.unshift({
        time: timeString,
        message: message
      });
      
      // Keep history limited to most recent 20 events
      if (connectionHistory.length > 20) {
        connectionHistory.pop();
      }
      
      // Update display
      connectionHistoryEl.innerHTML = '';
      connectionHistory.forEach(event => {
        const eventEl = document.createElement('div');
        eventEl.className = 'client-item';
        
        const timeSpan = document.createElement('span');
        timeSpan.textContent = event.time;
        
        const messageSpan = document.createElement('span');
        messageSpan.textContent = event.message;
        
        eventEl.appendChild(timeSpan);
        eventEl.appendChild(messageSpan);
        connectionHistoryEl.appendChild(eventEl);
      });
    }
    
    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      
      return [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        secs.toString().padStart(2, '0')
      ].join(':');
    }
  </script>
  <script src="nav.js"></script>
</body>
</html>
