<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connection Status - Radian</title>
  <!-- External Dependencies -->
  <script src="/socket.io/socket.io.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <style>
    .connection-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    
    .connection-block {
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }
    
    .connection-list {
      max-height: 300px;
      overflow-y: auto;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 10px;
    }
    
    .client-item {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .client-item:last-child {
      border-bottom: none;
    }
    
    .system-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    /* Mobile responsive styles for connections page */
    @media (max-width: 768px) {
      .connection-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }
      
      .system-info {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      .connection-block {
        padding: 12px;
      }
      
      .big-number {
        font-size: 2em !important;
      }
      
      .connection-stats {
        font-size: 1.1em !important;
      }
    }

    @media (max-width: 480px) {
      .connection-grid {
        gap: 10px;
      }
      
      .connection-block {
        padding: 10px;
      }
      
      .big-number {
        font-size: 1.8em !important;
      }
      
      .connection-stats {
        font-size: 1em !important;
      }
      
      .broadcast-info {
        flex-direction: column;
        gap: 10px;
        padding: 12px;
      }
      
      .admin-actions {
        flex-direction: column;
        gap: 8px;
      }
      
      .client-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
        padding: 6px;
      }
      
      .info-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
        font-size: 0.9rem;
      }
      
      .info-value {
        font-size: 0.85rem;
      }
      
      .connection-list {
        max-height: 250px;
        padding: 8px;
      }
    }
    
    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    
    .info-value {
      font-weight: bold;
    }
    
    .status-good {
      color: #4caf50;
    }
    
    .status-warning {
      color: #ff9800;
    }
    
    .status-error {
      color: #f44336;
    }
    
    .connection-stats {
      text-align: center;
      font-size: 1.2em;
      margin: 20px 0;
    }
    
    .big-number {
      font-size: 2.5em;
      font-weight: bold;
      margin: 5px 0;
    }
    
    .broadcast-info {
      display: flex;
      justify-content: space-between;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .admin-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    .admin-button {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      background-color: #1e88e5;
      color: white;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
    }
    
    .admin-button.danger {
      background-color: #e53935;
    }
    
    .admin-button:hover {
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <!-- Top Bar -->
  <div id="topBar" class="top-bar"></div>
  
  <!-- Main Dashboard Header -->
  <div class="telemetry-block">
    <h2>Connection Status Dashboard</h2>
    
    <!-- Summary Stats -->
    <div class="connection-stats">
      <div>Connected Clients</div>
      <div class="big-number" id="connectionCount">0</div>
      <div style="font-size: 0.9em; margin-top: -10px; color: #4caf50;">
        <span id="broadcastingCount">0</span> actively broadcasting
      </div>
      <div>Server Uptime: <span id="serverUptime">--:--:--</span></div>
    </div>
    
    <!-- Broadcaster Info -->
    <div class="broadcast-info">
      <div>
        <label>Current Driver:</label>
        <span id="currentDriver">--</span>
      </div>
      <div>
        <label>Session ID:</label>
        <span id="sessionId">--</span>
      </div>
    </div>
  </div>

  <!-- Detailed Connection Info -->
  <div class="telemetry-block">
    <h2>System Status <span class="info-badge" title="Detailed system information">ℹ️</span></h2>
    <div class="connection-grid">
      <!-- Connection List -->
      <div class="connection-block">
        <h3>Connected Clients</h3>
        <div class="connection-list" id="clientList">
          <div class="client-item">
            <span>No clients connected</span>
          </div>
        </div>
      </div>
      
      <!-- System Info -->
      <div class="connection-block">
        <h3>Server Information</h3>
        <div class="system-info">
          <div class="info-item">
            <span>Socket.io Status:</span>
            <span class="info-value status-good" id="socketStatus">Connected</span>
          </div>
          <div class="info-item">
            <span>Last Data Received:</span>
            <span class="info-value" id="lastDataTime">--:--:--</span>
          </div>
          <div class="info-item">
            <span>Telemetry Rate:</span>
            <span class="info-value" id="telemetryRate">-- Hz</span>
          </div>
          <div class="info-item">
            <span>API Status:</span>
            <span class="info-value status-good" id="apiStatus">Operational</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Admin Actions -->
    <div class="admin-actions">
      <button class="admin-button danger" id="resetButton">Reset All Data</button>
    </div>
  </div>

  <!-- Connection History -->
  <div class="telemetry-block">
    <h2>Connection History <span class="info-badge" title="Recent connection events">ℹ️</span></h2>
    <div class="connection-list" id="connectionHistory">
      <div class="client-item">
        <span>No connection history available</span>
      </div>
    </div>
  </div>

  <!-- JavaScript Resources -->
  <script src="storage-manager.js"></script>
  <script>
    // Socket.io connection (independent from telemetry.js)
    const socket = io('https://radianapp.onrender.com');
    
    // Connection tracking (using some variables from telemetry.js)
    let connectionStartTime = Date.now();
    let connectedClients = [];
    let connectionHistory = [];
    let lastConnectionInfo = null; // Store last connection info
    let previousConnectionInfo = null; // Store previous state for comparison
    
    // Telemetry rate tracking
    let telemetryPacketCount = 0;
    let telemetryStartTime = Date.now();
    let connectionsPageLastTelemetryTime = null; // Local variable for connections page
    
    // DOM elements (will be cached after DOM loads)
    let connectionCountEl, broadcastingCountEl, serverUptimeEl, currentDriverEl, sessionIdEl;
    let clientListEl, socketStatusEl, lastDataTimeEl, telemetryRateEl;
    let apiStatusEl, connectionHistoryEl, resetButton;
    
    // Initialize page
    document.addEventListener('DOMContentLoaded', () => {
      // Cache DOM elements after DOM is loaded
      connectionCountEl = document.getElementById('connectionCount');
      broadcastingCountEl = document.getElementById('broadcastingCount');
      serverUptimeEl = document.getElementById('serverUptime');
      currentDriverEl = document.getElementById('currentDriver');
      sessionIdEl = document.getElementById('sessionId');
      clientListEl = document.getElementById('clientList');
      socketStatusEl = document.getElementById('socketStatus');
      lastDataTimeEl = document.getElementById('lastDataTime');
      telemetryRateEl = document.getElementById('telemetryRate');
      apiStatusEl = document.getElementById('apiStatus');
      connectionHistoryEl = document.getElementById('connectionHistory');
      
      // Cache buttons
      resetButton = document.getElementById('resetButton');
      updateConnectionTime();
      setInterval(updateConnectionTime, 1000);
      
      // Initialize telemetry display
      telemetryRateEl.textContent = '-- Hz';
      lastDataTimeEl.textContent = '--:--:--';
      
      // Periodically request connection info to stay updated (less frequently)
      setInterval(() => {
        if (socket.connected) {
          socket.emit('requestConnectionInfo');
        }
      }, 15000); // Every 15 seconds instead of 5
      
      // Set up button handlers
      resetButton.addEventListener('click', () => {
        if (confirm('Are you sure you want to reset all telemetry data for all connected clients?')) {
          socket.emit('resetTelemetryState');
          addConnectionEvent('Telemetry data reset initiated');
        }
      });
    });
    
    // Socket event handlers
    socket.on('connect', () => {
      console.log('Connected to server, requesting connection info...');
      socketStatusEl.textContent = 'Connected';
      socketStatusEl.className = 'info-value status-good';
      addConnectionEvent('Connected to server');
      
      // Request connection info after we're connected
      setTimeout(() => {
        socket.emit('requestConnectionInfo');
      }, 100); // Small delay to ensure server has processed our connection
    });
    
    socket.on('disconnect', () => {
      socketStatusEl.textContent = 'Disconnected';
      socketStatusEl.className = 'info-value status-error';
      addConnectionEvent('Disconnected from server');
    });
    
    socket.on('telemetry', (data) => {
      const now = new Date();
      connectionsPageLastTelemetryTime = now; // Use local variable
      lastDataTimeEl.textContent = `${now.toLocaleTimeString()}`;
      
      // Track telemetry rate
      telemetryPacketCount++;
      const elapsedSeconds = (Date.now() - telemetryStartTime) / 1000;
      
      if (elapsedSeconds >= 1) { // Update rate every second
        const rate = (telemetryPacketCount / elapsedSeconds).toFixed(1);
        telemetryRateEl.textContent = `${rate} Hz`;
        
        // Reset counters for next calculation
        telemetryPacketCount = 0;
        telemetryStartTime = Date.now();
      }
    });
    
    socket.on('connectionInfo', (info) => {
      console.log('Received connection info:', info);
      
      // Check what changed and only log meaningful events
      let changesDetected = [];
      
      if (previousConnectionInfo) {
        // Check client count change
        if (info.clientCount !== previousConnectionInfo.clientCount) {
          changesDetected.push(`Client count: ${previousConnectionInfo.clientCount} → ${info.clientCount}`);
        }
        
        // Check API status change
        if (info.apiStatus !== previousConnectionInfo.apiStatus) {
          changesDetected.push(`API status: ${previousConnectionInfo.apiStatus} → ${info.apiStatus}`);
        }
        
        // Check storage status change
        if (info.storageActive !== previousConnectionInfo.storageActive) {
          changesDetected.push(`Storage: ${previousConnectionInfo.storageActive ? 'Active' : 'Inactive'} → ${info.storageActive ? 'Active' : 'Inactive'}`);
        }
      } else {
        // First time receiving connection info
        changesDetected.push('Initial connection info received');
      }
      
      // Store previous state for next comparison
      previousConnectionInfo = {
        clientCount: info.clientCount,
        apiStatus: info.apiStatus,
        storageActive: info.storageActive
      };
      
      // Store last connection info
      lastConnectionInfo = info;
      
      // Update connection count
      connectionCountEl.textContent = info.clientCount || '0';
      
      // Calculate and update broadcasting count
      const clients = info.clients || [];
      const broadcastingCount = clients.filter(client => client.broadcastingEnabled).length;
      broadcastingCountEl.textContent = broadcastingCount;
      
      // Update client list
      updateClientList(clients);
      
      // Update server info
      serverUptimeEl.textContent = formatTime(info.uptime || 0);
      apiStatusEl.textContent = info.apiStatus || 'Unknown';
      apiStatusEl.className = info.apiStatus === 'Operational' 
        ? 'info-value status-good' 
        : 'info-value status-warning';
      
      // Only log if there were meaningful changes
      if (changesDetected.length > 0) {
        changesDetected.forEach(change => addConnectionEvent(change));
      }
    });
    
    socket.on('currentBroadcaster', (info) => {
      console.log('Received currentBroadcaster:', info);
      
      // Only update if the driver or sessionId actually changed
      const currentDriver = currentDriverEl.textContent;
      const currentSession = sessionIdEl.textContent;
      
      if (info.driver !== currentDriver || info.sessionId !== currentSession) {
        currentDriverEl.textContent = info.driver || '--';
        sessionIdEl.textContent = info.sessionId || '--';
        addConnectionEvent(`Broadcaster updated: ${info.driver} (Session: ${info.sessionId})`);
      }
    });
    
    socket.on('clientConnect', (clientInfo) => {
      // Check if this client is broadcasting (has driver name)
      const clientData = lastConnectionInfo?.clients?.find(c => c.id === clientInfo.id);
      const displayName = clientData?.driverName ? 
        `${clientData.driverName} (${clientInfo.id.substring(0, 6)})` : 
        `Client ${clientInfo.id.substring(0, 6)}`;
      
      addConnectionEvent(`New client connected: ${displayName}`);
      socket.emit('requestConnectionInfo');
    });
    
    socket.on('clientDisconnect', (clientInfo) => {
      addConnectionEvent(`Client disconnected: ${clientInfo.id.substring(0, 6)}`);
      socket.emit('requestConnectionInfo');
    });
    
    socket.on('telemetryStateReset', () => {
      addConnectionEvent('Telemetry data has been reset by another user');
    });
    
    // Helper functions
    function updateConnectionTime() {
      const elapsedSeconds = Math.floor((Date.now() - connectionStartTime) / 1000);
      serverUptimeEl.textContent = formatTime(elapsedSeconds);
      
      // Check if telemetry data is stale
      if (connectionsPageLastTelemetryTime && typeof connectionsPageLastTelemetryTime.getTime === 'function') {
        const timeSinceLastData = Math.floor((Date.now() - connectionsPageLastTelemetryTime.getTime()) / 1000);
        if (timeSinceLastData > 5) { // No data for 5+ seconds
          telemetryRateEl.textContent = '0 Hz';
          telemetryRateEl.style.color = '#f44336'; // Red color for no data
        } else {
          telemetryRateEl.style.color = '#4caf50'; // Green color for active data
        }
      } else {
        telemetryRateEl.textContent = '-- Hz';
        telemetryRateEl.style.color = '#ff9800'; // Orange for waiting
      }
    }
    
    function updateClientList(clients) {
      console.log('Updating client list with:', clients);
      if (!clientListEl) return;
      
      clientListEl.innerHTML = '';
      if (clients.length === 0) {
        clientListEl.innerHTML = '<div class="client-item"><span>No clients connected</span></div>';
        return;
      }
      
      clients.forEach(client => {
        const clientEl = document.createElement('div');
        clientEl.className = 'client-item';
        clientEl.style.justifyContent = 'center'; // Center the content since no time element
        
        const idSpan = document.createElement('span');
        // Determine broadcasting status based on broadcastingEnabled field
        const isBroadcasting = client.broadcastingEnabled;
        
        // If driver name is available, use it for identification
        if (client.driverName) {
          const status = isBroadcasting ? ' 📡 BROADCASTING' : ' 🔗 Connected';
          const statusColor = isBroadcasting ? '#4caf50' : '#ff9800';
          
          idSpan.innerHTML = `${client.driverName}<br><small style="color: ${statusColor};">${status}</small>`;
          idSpan.style.fontWeight = 'bold';
          idSpan.style.color = isBroadcasting ? '#4caf50' : '#ffffff';
          idSpan.style.textAlign = 'center';
        } else {
          const status = isBroadcasting ? ' 📡 BROADCASTING' : ' 🔗 Connected';
          const statusColor = isBroadcasting ? '#4caf50' : '#ff9800';
          idSpan.innerHTML = `ID: ${client.id.substring(0, 6)}...<br><small style="color: ${statusColor};">${status}</small>`;
          idSpan.style.textAlign = 'center';
        }
        
        clientEl.appendChild(idSpan);
        clientListEl.appendChild(clientEl);
      });
    }
    
    function addConnectionEvent(message) {
      if (!connectionHistoryEl) return;
      
      const now = new Date();
      const timeString = now.toLocaleTimeString();
      
      connectionHistory.unshift({
        time: timeString,
        message: message
      });
      
      // Keep history limited to most recent 20 events
      if (connectionHistory.length > 20) {
        connectionHistory.pop();
      }
      
      // Update display
      connectionHistoryEl.innerHTML = '';
      connectionHistory.forEach(event => {
        const eventEl = document.createElement('div');
        eventEl.className = 'client-item';
        
        const timeSpan = document.createElement('span');
        timeSpan.textContent = event.time;
        
        const messageSpan = document.createElement('span');
        messageSpan.textContent = event.message;
        
        eventEl.appendChild(timeSpan);
        eventEl.appendChild(messageSpan);
        connectionHistoryEl.appendChild(eventEl);
      });
    }
    
    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      
      return [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        secs.toString().padStart(2, '0')
      ].join(':');
    }
  </script>
  <script src="nav.js"></script>
</body>
</html>
