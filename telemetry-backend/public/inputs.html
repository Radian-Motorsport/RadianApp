<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Strategy Planner</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body {
      background-color: #121212;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      margin: 0;
      padding: 0 20px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #1a1a1a;
      padding: 10px 20px;
      border-bottom: 1px solid #333;
    }

    .top-bar button {
      background-color: #333;
      color: #0f0;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      font-family: inherit;
      cursor: pointer;
    }

    #refreshRate {
      color: #0f0;
      font-size: 0.9rem;
    }

    .telemetry-block {
      margin-top: 20px;
    }

    .inputs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }

    .inputs-grid div {
      background-color: #1e1e1e;
      padding: 10px;
      border-radius: 6px;
      text-align: center;
      font-size: 0.9rem;
      border: 1px solid #333;
    }

    .inputs-grid label {
      display: block;
      font-weight: bold;
      color: #0f0;
      margin-bottom: 4px;
    }

    .inputs-grid span {
      color: #fff;
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: #111;
      border: 1px solid #333;
    }

    h2 {
      margin-top: 30px;
      color: #0f0;
    }

    ul {
      list-style: none;
      padding: 0;
    }

    ul li {
      margin-bottom: 6px;
    }
  </style>
</head>
<body>

  <!-- Top Bar -->
  <div class="top-bar">
    <button onclick="location.href='index.html'">Strategy</button>
    <div id="refreshRate">Refresh Rate: --</div>
  </div>

  <!-- Track Map -->
  <div class="track-map">
    <canvas id="trackCanvas" width="600" height="600"></canvas>
  </div>

  <!-- Telemetry Block -->
  <div class="telemetry-block">
    <canvas id="pedalCanvas" width="600" height="200"></canvas>

    <div class="inputs-grid">
      <div><label>Throttle</label><span id="Throttle">--</span></div>
      <div><label>Brake</label><span id="Brake">--</span></div>
      <div><label>Gear</label><span id="Gear">--</span></div>
      <div><label>RPM</label><span id="RPM">--</span></div>
      <div><label>Speed</label><span id="Speed">--</span></div>
      <div><label>Steering</label><span id="Steering">--</span></div>
    </div>
  </div>

  <!-- Status -->
  <h2>Status</h2>
  <ul>
    <li>IsOnTrack: <span id="IsOnTrack">--</span></li>
    <li>IsOnTrackCar: <span id="IsOnTrackCar">--</span></li>
    <li>IsInGarage: <span id="IsInGarage">--</span></li>
    <li>PlayerCarPosition: <span id="PlayerCarPosition">--</span></li>
    <li>PlayerCarClassPosition: <span id="PlayerCarClassPosition">--</span></li>
    <li>PlayerTrackSurface: <span id="PlayerTrackSurface">--</span></li>
    <li>PlayerCarIdx: <span id="PlayerCarIdx">--</span></li>
    <li>Team Incidents: <span id="PlayerCarTeamIncidentCount">--</span></li>
    <li>My Incidents: <span id="PlayerCarMyIncidentCount">--</span></li>
    <li>Driver Incidents: <span id="PlayerCarDriverIncidentCount">--</span></li>
    <li>LapDistPct: <span id="LapDistPct">--</span></li>
    <li>RaceLaps: <span id="RaceLaps">--</span></li>
    <li>CarDistAhead: <span id="CarDistAhead">--</span></li>
    <li>CarDistBehind: <span id="CarDistBehind">--</span></li>
  </ul>

  <!-- Driver Controls -->
  <h2>Driver Controls</h2>
  <ul>
    <li>Pit Speed Limiter: <span id="dcPitSpeedLimiterToggle">--</span></li>
    <li>Fuel Auto Fill Enabled: <span id="dpFuelAutoFillEnabled">--</span></li>
    <li>Fuel Auto Fill Active: <span id="dpFuelAutoFillActive">--</span></li>
    <li>Brake Bias: <span id="dcBrakeBias">--</span></li>
    <li>Traction Control: <span id="dcTractionControl">--</span></li>
    <li>ABS: <span id="dcABS">--</span></li>
    <li>Fuel Level: <span id="FuelLevel">--</span></li>
  </ul>

  <!-- Environment -->
  <h2>Environment</h2>
  
  
  <h2>Environment Trends</h2>
    <canvas id="envCanvas" width="600" height="200"></canvas>


  <ul>
    <li>Track Temp: <span id="TrackTemp">--</span></li>
    <li>Air Temp: <span id="AirTemp">--</span></li>
    <li>Track Wetness: <span id="TrackWetness">--</span></li>
    <li>Skies: <span id="Skies">--</span></li>
    <li>Air Density: <span id="AirDensity">--</span></li>
    <li>Air Pressure: <span id="AirPressure">--</span></li>
    <li>Wind Velocity: <span id="WindVel">--</span></li>
    <li>Wind Direction: <span id="WindDir">--</span></li>
    <li>Humidity: <span id="RelativeHumidity">--</span></li>
    <li>Fog Level: <span id="FogLevel">--</span></li>
    <li>Precipitation: <span id="Precipitation">--</span></li>
  </ul>


<script>
const socket = io('https://radianapp.onrender.com');

// Load the car icon once
const carImg = new Image();
carImg.src = 'icon-active.png';

// === Pedal Canvas Setup ===
const canvas = document.getElementById('pedalCanvas');
const ctx = canvas.getContext('2d');
const buffer = [];
const MAX_POINTS = 300;

// === Track Map Setup ===
const trackCanvas = document.getElementById('trackCanvas');
const trackCtx = trackCanvas.getContext('2d');
let lapStarted = false;
let lapCompleted = false;
let currentLap = [];
let finalLap = [];
let lapBuffer = [];
let lapYaw = [];          // yaw values for current lap
let finalLapYaw = [];     // yaw values for completed lap

let liveLapPct = 0;
let prevLapPct = 0;
let targetLapPct = 0;
let lastPctUpdateTime = performance.now();

const telemetryHz = 10;

// === Environment Trends Setup ===
const envCanvas = document.getElementById('envCanvas');
const envCtx = envCanvas.getContext('2d');
const envBuffer = [];
const MAX_ENV_POINTS = 600;

// === Refresh Rate Setup ===
const refreshRateDisplay = document.getElementById('refreshRate');
let lastTelemetryTime = null;

// === Telemetry Listener for UI/inputs ===
socket.on('telemetry', (data) => {
  const values = data?.values;
  if (!values) return;

  // Lap % interpolation targets
  prevLapPct = targetLapPct;
  targetLapPct = values.LapDistPct;
  lastPctUpdateTime = performance.now();
  liveLapPct = values.LapDistPct;

  // Refresh rate display
  const now = Date.now();
  if (lastTelemetryTime) {
    const interval = now - lastTelemetryTime;
    const hz = (1000 / interval).toFixed(1);
    refreshRateDisplay.textContent = `Refresh Rate: ${hz} Hz (${interval} ms)`;
  }
  lastTelemetryTime = now;

  // Pedal input buffer
  buffer.push({
    throttle: values.ThrottleRaw * 100,
    brake: values.Brake * 100,
    rpm: (values.RPM / 10000) * 100
  });
  if (buffer.length > MAX_POINTS) buffer.shift();

  // Environment buffer
  envBuffer.push({
    trackTemp: values.TrackTemp,
    airTemp: values.AirTemp,
    humidity: values.RelativeHumidity
  });
  if (envBuffer.length > MAX_ENV_POINTS) envBuffer.shift();

  // === DOM Updates: Status ===
  document.getElementById('IsOnTrack').textContent = values.IsOnTrack;
  document.getElementById('IsOnTrackCar').textContent = values.IsOnTrackCar;
  document.getElementById('IsInGarage').textContent = values.IsInGarage;
  document.getElementById('PlayerCarPosition').textContent = values.PlayerCarPosition;
  document.getElementById('PlayerCarClassPosition').textContent = values.PlayerCarClassPosition;
  document.getElementById('PlayerTrackSurface').textContent = values.PlayerTrackSurface;
  document.getElementById('PlayerCarIdx').textContent = values.PlayerCarIdx;
  document.getElementById('PlayerCarTeamIncidentCount').textContent = values.PlayerCarTeamIncidentCount;
  document.getElementById('PlayerCarMyIncidentCount').textContent = values.PlayerCarMyIncidentCount;
  document.getElementById('PlayerCarDriverIncidentCount').textContent = values.PlayerCarDriverIncidentCount;
  document.getElementById('LapDistPct').textContent = values.LapDistPct?.toFixed(3);
  document.getElementById('RaceLaps').textContent = values.RaceLaps;
  document.getElementById('CarDistAhead').textContent = values.CarDistAhead;
  document.getElementById('CarDistBehind').textContent = values.CarDistBehind;

  // === DOM Updates: Driver Inputs ===
  document.getElementById('Throttle').textContent = values.Throttle;
  document.getElementById('Brake').textContent = values.Brake;
  document.getElementById('Gear').textContent = values.Gear;
  document.getElementById('RPM').textContent = values.RPM?.toFixed(0);
  document.getElementById('Speed').textContent = values.Speed?.toFixed(3);
  document.getElementById('Steering').textContent = values.SteeringWheelAngle;

  // === DOM Updates: Driver Controls ===
  document.getElementById('dcPitSpeedLimiterToggle').textContent = values.dcPitSpeedLimiterToggle;
  document.getElementById('dpFuelAutoFillEnabled').textContent = values.dpFuelAutoFillEnabled;
  document.getElementById('dpFuelAutoFillActive').textContent = values.dpFuelAutoFillActive;
  document.getElementById('dcBrakeBias').textContent = values.dcBrakeBias?.toFixed(2);
  document.getElementById('dcTractionControl').textContent = values.dcTractionControl;
  document.getElementById('dcABS').textContent = values.dcABS;
  document.getElementById('FuelLevel').textContent = values.FuelLevel?.toFixed(2);

  // === DOM Updates: Environment ===
  document.getElementById('TrackTemp').textContent = values.TrackTemp?.toFixed(1);
  document.getElementById('AirTemp').textContent = values.AirTemp?.toFixed(1);
  document.getElementById('TrackWetness').textContent = values.TrackWetness;
  document.getElementById('Skies').textContent = values.Skies;
  document.getElementById('AirDensity').textContent = values.AirDensity?.toFixed(3);
  document.getElementById('AirPressure').textContent = values.AirPressure?.toFixed(1);
  document.getElementById('WindVel').textContent = values.WindVel?.toFixed(1);
  document.getElementById('WindDir').textContent = values.WindDir?.toFixed(1);
  document.getElementById('RelativeHumidity').textContent = values.RelativeHumidity?.toFixed(2);
  document.getElementById('FogLevel').textContent = values.FogLevel;
  document.getElementById('Precipitation').textContent = values.Precipitation?.toFixed(3);
});

// === Draw Pedal Graph ===
function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Throttle (green)
  ctx.beginPath();
  ctx.strokeStyle = 'lime';
  buffer.forEach((point, i) => {
    const x = i * 2;
    const y = canvas.height - point.throttle;
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Brake (red)
  ctx.beginPath();
  ctx.strokeStyle = 'red';
  buffer.forEach((point, i) => {
    const x = i * 2;
    const y = canvas.height - point.brake;
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.stroke();

  // RPM (yellow)
  ctx.beginPath();
  ctx.strokeStyle = 'yellow';
  buffer.forEach((point, i) => {
    const x = i * 2;
    const y = canvas.height - point.rpm;
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.stroke();

  requestAnimationFrame(drawGraph);
}
requestAnimationFrame(drawGraph);

// === Draw Environment Trends ===
function drawEnvGraph() {
  envCtx.clearRect(0, 0, envCanvas.width, envCanvas.height);

  // Track Temp (orange)
  envCtx.beginPath();
  envCtx.strokeStyle = 'orange';
  envBuffer.forEach((point, i) => {
    const x = i;
    const y = envCanvas.height - point.trackTemp * 2;
    i === 0 ? envCtx.moveTo(x, y) : envCtx.lineTo(x, y);
  });
  envCtx.stroke();

  // Air Temp (cyan)
  envCtx.beginPath();
  envCtx.strokeStyle = 'cyan';
  envBuffer.forEach((point, i) => {
    const x = i;
    const y = envCanvas.height - point.airTemp * 2;
    i === 0 ? envCtx.moveTo(x, y) : envCtx.lineTo(x, y);
  });
  envCtx.stroke();

  // Humidity (purple)
  envCtx.beginPath();
  envCtx.strokeStyle = 'purple';
  envBuffer.forEach((point, i) => {
    const x = i;
    const y = envCanvas.height - point.humidity;
    i === 0 ? envCtx.moveTo(x, y) : envCtx.lineTo(x, y);
  });
  envCtx.stroke();

  requestAnimationFrame(drawEnvGraph);
}
requestAnimationFrame(drawEnvGraph);

let lastLapPct = 0;

// === Telemetry Listener for lap tracking ===
socket.on('telemetry', (data) => {
  const values = data?.values;
  if (!values || lapCompleted) return;

  const { Speed, YawNorth, LapDistPct } = values;
  const dt = 1 / 60;

  // Track position
  const last = lapBuffer.length > 0 ? lapBuffer[lapBuffer.length - 1] : { x: 300, y: 300 };
  const newX = last.x + Math.cos(YawNorth) * Speed * dt;
  const newY = last.y + Math.sin(YawNorth) * Speed * dt;
  lapBuffer.push({ x: newX, y: newY });
  lapYaw.push(YawNorth);

  // Detect lap wrap
  if (LapDistPct < lastLapPct - 0.5) {
    if (!lapStarted) {
      lapStarted = true;
      currentLap = [...lapBuffer];
      lapBuffer = [];
      finalLapYaw = [...lapYaw];
      lapYaw = [];
    } else {
      lapCompleted = true;
      finalLap = [...lapBuffer];
      finalLapYaw = [...lapYaw];
    }
  }

  lastLapPct = LapDistPct;
});

// === Yaw-based straight section finder ===
function findStraightBlendZoneFromYaw(points, yawArray, yawRateThreshold = 0.001) {
  const total = points.length;
  const yawDelta = (a, b) => {
    let diff = a - b;
    while (diff > Math.PI) diff -= 2 * Math.PI;
    while (diff < -Math.PI) diff += 2 * Math.PI;
    return diff;
  };

  let startIdx = 0;
  for (let i = total - 1; i > 0; i--) {
    if (Math.abs(yawDelta(yawArray[i], yawArray[i - 1])) > yawRateThreshold) {
      startIdx = (i + 1) % total;
      break;
    }
  }

  let endIdx = 0;
  for (let i = 1; i < total; i++) {
    if (Math.abs(yawDelta(yawArray[i], yawArray[i - 1])) > yawRateThreshold) {
      endIdx = (i - 1 + total) % total;
      break;
    }
  }

  return { startIdx, endIdx };
}

// === Blend lap ends along a straight section ===
function blendLapEndsStraightSection(points, startIdx, endIdx) {
  const blended = [...points];
  const total = points.length;
  const dx = points[(startIdx + 1) % total].x - points[startIdx].x;
  const dy = points[(startIdx + 1) % total].y - points[startIdx].y;
  const len = Math.hypot(dx, dy) || 1;
  const ux = dx / len;
  const uy = dy / len;

  let i = startIdx;
  while (true) {
    const dist = ((i - startIdx + total) % total) * len;
    blended[i] = {
      x: points[startIdx].x + ux * dist,
      y: points[startIdx].y + uy * dist
    };
    if (i === endIdx) break;
    i = (i + 1) % total;
  }
  return blended;
}

// === Smoothing Function ===
function smooth(points, windowSize = 5) {
  return points.map((pt, i) => {
    const slice = points.slice(Math.max(0, i - windowSize), i + 1);
    const avgX = slice.reduce((sum, p) => sum + p.x, 0) / slice.length;
    const avgY = slice.reduce((sum, p) => sum + p.y, 0) / slice.length;
    return { x: avgX, y: avgY };
  });
}

// Smooth an array of numbers with a simple moving average
function smoothArray(arr, windowSize = 3) {
  return arr.map((val, i) => {
    const start = Math.max(0, i - windowSize);
    const slice = arr.slice(start, i + 1);
    return slice.reduce((sum, v) => sum + v, 0) / slice.length;
  });
}

// Find straight section based on yaw *rate of change*
function findStraightBlendZoneFromYaw(points, yawArray, yawRateThreshold = 0.001) {
  const total = points.length;
  const yawDelta = (a, b) => {
    let diff = a - b;
    while (diff > Math.PI) diff -= 2 * Math.PI;
    while (diff < -Math.PI) diff += 2 * Math.PI;
    return diff;
  };

  const smoothYaw = smoothArray(yawArray, 3);

  let startIdx = 0;
  for (let i = total - 1; i > 0; i--) {
    if (Math.abs(yawDelta(smoothYaw[i], smoothYaw[i - 1])) > yawRateThreshold) {
      startIdx = (i + 1) % total;
      break;
    }
  }

  let endIdx = 0;
  for (let i = 1; i < total; i++) {
    if (Math.abs(yawDelta(smoothYaw[i], smoothYaw[i - 1])) > yawRateThreshold) {
      endIdx = (i - 1 + total) % total;
      break;
    }
  }

  return { startIdx, endIdx };
}

// Blend into/out of a straight section gradually
function blendLapEndsStraightSection(points, startIdx, endIdx, fadePoints = 5) {
  const blended = [...points];
  const total = points.length;

  // Average heading vector over first few points of the straight
  let avgDx = 0, avgDy = 0, count = 0;
  let i = startIdx;
  while (true) {
    const next = (i + 1) % total;
    avgDx += points[next].x - points[i].x;
    avgDy += points[next].y - points[i].y;
    count++;
    if (i === endIdx) break;
    i = next;
  }
  avgDx /= count;
  avgDy /= count;
  const len = Math.hypot(avgDx, avgDy) || 1;
  const ux = avgDx / len;
  const uy = avgDy / len;

  // Walk through the straight section
  i = startIdx;
  let dist = 0;
  while (true) {
    const fadeIn = Math.min(1, ((i - startIdx + total) % total) / fadePoints);
    const fadeOut = Math.min(1, ((endIdx - i + total) % total) / fadePoints);
    const alpha = Math.min(fadeIn, fadeOut); // 0→1→0 across the section

    const straightX = points[startIdx].x + ux * dist;
    const straightY = points[startIdx].y + uy * dist;

    blended[i] = {
      x: points[i].x * (1 - alpha) + straightX * alpha,
      y: points[i].y * (1 - alpha) + straightY * alpha
    };

    if (i === endIdx) break;
    const next = (i + 1) % total;
    dist += Math.hypot(points[next].x - points[i].x, points[next].y - points[i].y);
    i = next;
  }

  return blended;
}



// === Draw Final Lap Only ===
function drawTrack() {
  trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);

  if (finalLap.length > 0) {
    let smoothed = smooth(finalLap);

    // --- Yaw-aware blend ---
   if (finalLapYaw && finalLapYaw.length === smoothed.length) {
  const { startIdx, endIdx } = findStraightBlendZoneFromYaw(smoothed, finalLapYaw, 0.001);
  smoothed = blendLapEndsStraightSection(smoothed, startIdx, endIdx, 5); // fade over 5 points
  }

    // Auto-scale and center
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    smoothed.forEach(pt => {
      minX = Math.min(minX, pt.x);
      maxX = Math.max(maxX, pt.x);
      minY = Math.min(minY, pt.y);
      maxY = Math.max(maxY, pt.y);
    });

    const padding = 20;
    const traceWidth = maxX - minX;
    const traceHeight = maxY - minY;
    const scaleX = (trackCanvas.width - padding * 2) / traceWidth;
    const scaleY = (trackCanvas.height - padding * 2) / traceHeight;
    const autoScale = Math.min(scaleX, scaleY);
    const offsetX = (trackCanvas.width - traceWidth * autoScale) / 2 - minX * autoScale;
    const offsetY = (trackCanvas.height - traceHeight * autoScale) / 2 - minY * autoScale;

    // Draw path
    trackCtx.beginPath();
    smoothed.forEach((pt, i) => {
      const sx = pt.x * autoScale + offsetX;
      const sy = pt.y * autoScale + offsetY;
      i === 0 ? trackCtx.moveTo(sx, sy) : trackCtx.lineTo(sx, sy);
    });
    trackCtx.lineTo(smoothed[0].x * autoScale + offsetX, smoothed[0].y * autoScale + offsetY);
    trackCtx.strokeStyle = 'white';
    trackCtx.stroke();
    
    // Finish line marker
    const finishX = smoothed[0].x * autoScale + offsetX;
    const finishY = smoothed[0].y * autoScale + offsetY;
    trackCtx.strokeStyle = 'red';
    trackCtx.lineWidth = 2;
    trackCtx.beginPath();
    trackCtx.moveTo(finishX - 5, finishY - 5);
    trackCtx.lineTo(finishX + 5, finishY + 5);
    trackCtx.stroke();
    trackCtx.lineWidth = 1;

    // Live position marker
    if (liveLapPct > 0 && liveLapPct <= 1) {
      const elapsed = (performance.now() - lastPctUpdateTime) / 1000;
      const lerpFactor = Math.min(elapsed * telemetryHz, 1);
      let pct = prevLapPct + (targetLapPct - prevLapPct) * lerpFactor;

      // Wrap-around handling
      if (targetLapPct < prevLapPct && (prevLapPct - targetLapPct) > 0.5) {
        pct = prevLapPct + ((targetLapPct + 1) - prevLapPct) * lerpFactor;
        if (pct > 1) pct -= 1;
      }

      const idx = Math.floor(pct * smoothed.length);
      const nextIdx = (idx + 1) % smoothed.length;
      const t = (pct * smoothed.length) - idx;
      const px = smoothed[idx].x + (smoothed[nextIdx].x - smoothed[idx].x) * t;
      const py = smoothed[idx].y + (smoothed[nextIdx].y - smoothed[idx].y) * t;

      const markerX = px * autoScale + offsetX;
      const markerY = py * autoScale + offsetY;

      const iconSize = 16;
      trackCtx.drawImage(carImg, markerX - iconSize / 2, markerY - iconSize / 2, iconSize, iconSize);
    }
  }

  requestAnimationFrame(drawTrack);
}
requestAnimationFrame(drawTrack);





</script>

</body>
</html>






